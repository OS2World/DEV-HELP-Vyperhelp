/***************************************************************************
 * File...... D:\proj\Generator\Generator.cpp
 * Author.... Mat
 * Date...... 10/24/95
 *
 * Implementation for generic Generator -- provides common functions
 * used by different Generator variations.
 *
 * Copyright (C) 1995 Data Sciences, Inc.
 ***************************************************************************/

// Standard C
#include <stdlib.h>
#include <time.h>

// Standard C++
#include <iostream.h>

// Generator
#include "MekTek.hpp"
#include "Generator.hpp"
#include "ArtSet.hpp"
#include "WindowSet.hpp"

// static data
CurrentDate  Generator::_date;
Registration Generator::_registration;

// local functions
static Boolean removeLeadingPeriod( IString & string );



/***************************************************************************
 * Procedure.. Generator::Generator()
 * Author..... Mat
 * Date....... 10/24/95
 *
 * Constructor: initializes window list
 ***************************************************************************/
Generator::Generator( Boolean allowNag ):
    _windows( new WindowSet ),
    _arts( new ArtSet ),
    _output( 0 ),
    _allowNag( allowNag ),
    _nagCount( 0 )
{
  IASSERTSTATE( _windows );
  IASSERTSTATE( _arts );

  // check for an expired copy
  ExpirationDate expires = registration().key().expires();
  if ( expires < _date )
    ITHROW( IException( expires.notice() ) );

  // nagging should be enabled only if there is an expiration date and no user name
  if ( ! expires || registration().name().length() )
    _allowNag = false;

  // seed the random number generator if nagging is allowed
  if ( _allowNag )
    srand( clock() );
}

Generator::~Generator()
{
  delete _windows;
  delete _arts;
}

void Generator::finish()
{
  closeOutput();
}


// ---------- VERSION ------------

#ifndef VVERSION
  #define VVERSION
#endif
IString Generator::version()
{
  return IString(VVERSION);
}

// ---------- CREDITS ------------

IString Generator::credits() const
{
  return IString("Generated by VyperHelp on ") + _date.asString("%x.");
}


// ---------- REGISTRATION ------------

void Generator::setInputFilename( const IString & filename )
{
  // validate current date
  _date.validate( filename );

  // check for an expired copy
  ExpirationDate expires = registration().key().expires();
  if ( expires < _date )
    ITHROW( IException( expires.notice() ) );
}


// ---------- WINDOW SUPPORT ------------

/***************************************************************************
 * Procedure.. Generator::defineWindow
 * Author..... Mat
 * Date....... 10/24/95
 *
 * Adds the given window to a keyed set of windows
 ***************************************************************************/
Generator & Generator::defineWindow( const WindowDef & window )
{
  _windows->add( window );
  return *this;
}


/***************************************************************************
 * Procedure.. Generator::hasWindowWithId
 * Author..... Mat
 * Date....... 10/24/95
 *
 * Returns true if a window with the specified id is in the set of defined
 * windows.
 ***************************************************************************/
Boolean           Generator::hasWindowWithId( int id ) const
{
  return _windows->containsElementWithKey( id );
}


/***************************************************************************
 * Procedure.. Generator::windowWithId
 * Author..... Mat
 * Date....... 10/24/95
 *
 * Returns a reference to the window with the specified id.  If no window
 * has been defined with the given id, an exception is thrown.
 ***************************************************************************/
const WindowDef & Generator::windowWithId( int id ) const
{
  WindowSet::Cursor cursor( *_windows );
  _windows->locateElementWithKey( id, cursor );
  MEKASSERT( cursor.isValid() );
  return cursor.element();
}


INumber Generator::numberOfWindows() const
{
  return _windows->numberOfElements();
}


const WindowDef & Generator::window( IPosition index ) const
{
  return _windows->elementAtPosition( index );
}


// ---------- ART SUPPORT ------------

Generator &  Generator::defineArt( const ArtDef & art )
{
  _arts->add( art );
  return *this;
}


Boolean Generator::hasArtWithId( const IString & id ) const
{
  return _arts->containsElementWithKey( id );
}


const ArtDef & Generator::artWithId( const IString & id ) const
{
  ArtSet::Cursor cursor( *_arts );
  _arts->locateElementWithKey( id, cursor );
  MEKASSERT( cursor.isValid() );
  return cursor.element();
}


INumber Generator::numberOfArts() const
{
  return _arts->numberOfElements();
}


const ArtDef & Generator::art( IPosition index ) const
{
  return _arts->elementAtPosition( index );
}


// ---------- DIRECT STREAMING ------------

/***************************************************************************
 * Procedure.. Generator::operator<<( const IString & )
 * Author..... Mat
 * Date....... 12/5/95
 *
 * Allow direct streaming of strings via a TextGin
 ***************************************************************************/
Generator & Generator::operator<<( const IString & string )
{
  handleText( TextGin( string ) );
  return *this;
}

/***************************************************************************
 * Procedure.. Generator::operator<<( const Symbol & )
 * Author..... Mat
 * Date....... 12/5/95
 *
 * Allow direct streaming of Symbols via a SymbolGin
 ***************************************************************************/
Generator & Generator::operator<<( const Symbol & symbol )
{
  handleSymbol( SymbolGin( symbol ) );
  return *this;
}


Generator & Generator::operator<<( const Gin & gin )
{
  gin.streamTo( *this );
  return *this;
}


// ---------- NAG TEXT ------------

/***************************************************************************
 * Procedure.. Generator::nag()
 * Author..... Mat
 * Date....... 5/27/99
 *
 * This function is called before starting a new section with SectionGin.
 * If the software is not registered, then some promotional "nag" text
 * is inserted at this point.  The content of the text is made somewhat
 * random, so it is more difficult to write a filter against it.
 ***************************************************************************/
void Generator::nag()
{
  // make sure this Generator allows nagging
  if ( ! _allowNag )
    return;

  // don't nag on the first call because a section is not active
  if ( ! _nagCount++ )
    return;

  // get a random number and use individual bits to enable specific nagging
  unsigned flags = (unsigned) rand();

  // skip everything occasionally
  if ( ( flags & 0x000000f0 ) == 0 )
    return;

  // paragraph and push for attributes
  *this << RulerGin( RulerGin::normal ) << ParaGin() << PushGin();

  // attributes
  if ( flags & 0x00000001 )
    *this << BoldGin( true );
  if ( flags & 0x00000002 )
    *this << ItalicGin( true );
  if ( flags & 0x00000004 )
    *this << UnderlineGin( true );
  if ( flags & 0x00000008 )
    *this << ColorGin( IColor( rand() % 16 ) );

  // credits
  if ( flags & 0x00000010 )
    *this << credits() << Symbol(' ');

  // registration
  if ( flags & 0x00000020 )
    *this << registration().notice() << Symbol(' ');

  // expiration
  if ( flags & 0x00000040 )
    *this << registration().key().expires().notice() << Symbol(' ');

  // promotional
  if ( flags & 0x00000080 )
    *this << "To register, visit http://www.vyperhelp.com.";

  // end group
  *this << PopGin();
}



// ---------- TEXT OUTPUT SUPPORT ------------

// character used as an optional delimiter for RTF output
unsigned char Generator::delimiter = '\0';


// throw an exception if a file error is detected
void Generator::checkOutput()
{
  MEKASSERT( _output );
  // use "void *" operator to check error state
  if ( ! *_output )
    MEKTHROWCERROR();
}


/***************************************************************************
 * Procedure.. Generator::setOutput
 * Author..... Mat
 *
 * Sets up text output.  output is the stream where output should be
 * directed.  maxLineLength is the maximum line length that should be output.
 * Lines are broken by substituting a \n for a space when the line reaches
 * the maximum length.
 *
 * The output mode is used to determine where and how to wrap lines:
 *
 *    text: wrap lines at any space, deleting the space
 *
 *    ipf, html: wrap lines at any space, deleting the space only if there
 *    is content on the line (as defined by the hasContent flag).
 *
 *    rtf: wrap lines before any of " {\}", but don't delete the
 *    character.  Also, wrap lines at Generator::delimiter, deleting it.  Finally,
 *    change any remaining Generator::delimiter to ' ' before sending.
 ***************************************************************************/
void Generator::setOutput( ostream & output, unsigned maxLineLength, OutputMode mode )
{
  // make sure it's closed first
  closeOutput();

  // set output stream
  _output = &output;

  // reset all output settings
  _maxLineLength = maxLineLength;
  _mode = mode;
  _wrapChars = " ";
  if ( mode == rtf )
  {
    _wrapChars += IString( "\\{}" );
    _wrapChars += IString( delimiter );
  }
  _minContentIndex = _maxContentIndex = _lineWrapIndex = 0;
  _line = IString();

  // check for errors
  checkOutput();
}


/***************************************************************************
 * Procedure.. Generator::outputText
 * Author..... Mat
 *
 * Send text to the output stream, using the options specified in "flags".
 ***************************************************************************/
void Generator::outputText( const IString & textOut, unsigned flags )
{
  enum
  {
    concatenate,
    wrapLine,
    wrapText
  }       action;
  Boolean canWrap = ((flags & noWrap) == 0);
  Boolean checkLeadingPeriod = ((flags & noLeadingPeriod) == noLeadingPeriod);
  Boolean isContent = ((flags & hasContent) == hasContent);

  MEKASSERT( _output );

  // SEND LINE BREAK IF REQUESTED
  if ( ( flags & breakBefore ) && _line.length() )
    outputLine();

  // RETURN IF NO TEXT
  if ( ! textOut.length() )
    return;

  // MAKE A COPY OF THE INCOMING TEXT
  IString text( textOut );

  // LOOP AS NECESSARY TO WRAP TEXT
  unsigned previousTextLength = 0;
  unsigned previousLineLength = 0;
  do
  {
    // DETERMINE CURRENT TEXT AND LINE LENGTH
    unsigned textLength = text.length();
    unsigned lineLength = _line.length();
    MEKASSERT( textLength != previousTextLength || lineLength != previousLineLength );

    // CHECK FOR ILLEGAL LEADING PERIOD
    if ( checkLeadingPeriod )
    {
      if ( removeLeadingPeriod( _line ) )
        lineLength = _line.length();
      if ( ! lineLength && removeLeadingPeriod( text ) )
        textLength = text.length();
    }

    // SAVE LENGTHS FOR LATER COMPARE
    previousTextLength = textLength;
    previousLineLength = lineLength;

    // DETERMINE WRAP INDEX IN NEW TEXT
    unsigned textWrapIndex = 0;  // index of space to wrap in text string
    if ( canWrap )
    {
      if ( lineLength <= _maxLineLength )
      {
        // look backwards from optimal wrap index
        textWrapIndex = wrapIndex( text, _maxLineLength - lineLength + 1 );
        // don't allow textWrapIndex = 1 if lineLength = 0 (empty line)
        if ( ! lineLength && textWrapIndex == 1 )
          textWrapIndex = 0;
      }
      if ( lineLength && ! textWrapIndex )
      {
        // line already too long, or no optimal wrap index found
        // look for first available wrap index
        textWrapIndex = text.indexOfAnyOf( _wrapChars );

        // in RTF mode, don't wrap if previous character is a "\"
        if ( _mode == rtf )
        {
          while ( ( textWrapIndex > 1 ) && ( text[textWrapIndex-1] == '\\' ) )
            textWrapIndex = text.indexOfAnyOf( _wrapChars, textWrapIndex+1 );
        }
      }
    }
    MEKASSERT( textWrapIndex <= text.length() );

    // DETERMINE PROPER ACTION
    if ( lineLength + textLength <= _maxLineLength )
    {
      // text fits on the line
      action = concatenate;
    }
    else if ( textWrapIndex && ( lineLength + textWrapIndex <= _maxLineLength + 1) )
    {
      // use optimal wrap index in new text
      action = wrapText;
    }
    else if ( _lineWrapIndex > 1 )
    {
      // use last saved wrap index
      action = wrapLine;
    }
    else if ( textWrapIndex )
    {
      // use last resort wrap index in new text (already past _maxLineLength)
      action = wrapText;
    }
    else
    {
      // no wraps possible, concatenate the new text
      action = concatenate;
    }

    switch ( action )
    {
      case concatenate:
        // update index of the last space if there is one in text
        if ( canWrap )
        {
          textWrapIndex = wrapIndex( text );
          if ( textWrapIndex )
          {
            _lineWrapIndex = lineLength + textWrapIndex;
            // don't allow line wrap index of 1 (empty line)
            if ( _lineWrapIndex == 1 )
              _lineWrapIndex = 0;
          }
        }
        // must concatenate line after calling wrapIndex()
        appendText( text, isContent );
        break;

      case wrapLine:
        MEKASSERT( _lineWrapIndex > 1 && lineLength && _lineWrapIndex <= lineLength );
        {
          // determine wrap index
          unsigned index = _lineWrapIndex;
          if ( ! keepWrapChar( index, _line[index] ) )
            index++;  // skip the space if the CR can act as a space

          // clip the line
          IString clippedLine = _line.subString( index );
          _line.remove( _lineWrapIndex );
          outputLine();

          // reset line settings
          _line = clippedLine;
          _lineWrapIndex = 0;

          // adjust content indexes
          if ( _maxContentIndex > index )
            _maxContentIndex = _maxContentIndex + 1 - index;
          else
            _maxContentIndex = 0;
          if ( _minContentIndex > index )
            _minContentIndex = _minContentIndex + 1 - index;
          else
            _minContentIndex = _maxContentIndex;
        }
        break;

      case wrapText:
        MEKASSERT( textWrapIndex && textLength && textWrapIndex <= textLength );
        MEKASSERT( textWrapIndex > 1 || lineLength > 1 );
        {
          // append part of the text to the line
          if ( textWrapIndex > 1 )
            appendText( text.subString( 1, textWrapIndex - 1 ), isContent );
          // remove part of text
          if ( keepWrapChar( _line.length(), text[textWrapIndex] ) )
            textWrapIndex--;  // include the space if the CR cannot act as a space
          if ( textWrapIndex )
            text.remove( 1, textWrapIndex );
          // send the new line
          outputLine();
        }
        break;
    }

  } while ( action != concatenate );


  // SEND LINE BREAK IF REQUESTED
  if ( ( flags & breakAfter ) && _line.length() )
    outputLine();
}


/***************************************************************************
 * Procedure.. Generator::appendText
 * Author..... Mat
 * Date....... 12/8/98
 *
 * Append text to the line and update the content indexes, if the text
 * contains content.
 ***************************************************************************/
void Generator::appendText( const IString & string, Boolean isContent )
{
  // update content index
  if ( isContent )
  {
    if ( ! _minContentIndex )
      _minContentIndex = _line.length() + 1;
    _maxContentIndex = _line.length() + string.length();
  }

  // append the text
  _line += string;
}


/***************************************************************************
 * Procedure.. Generator::keepWrapChar
 * Author..... Mat
 * Date....... 12/8/98
 *
 * For IPF and HTML, returns true if a space should be kept when wrapping the line at the
 * given index (instead of letting the \n take its place).  If the given
 * index is 0 (blank line), return false.
 *
 * For RTF, return true unless the wrap character is Generator::delimiter.
 *
 * For normal text, always return false.
 ***************************************************************************/
Boolean Generator::keepWrapChar( unsigned index, unsigned char ch )
{
  switch ( _mode )
  {
    case ipf:
    case html:
      return ( index && ( ! _minContentIndex || ( _minContentIndex >= index ) ) );

    case rtf:
      return ( ch != delimiter );
  }

  return false;
}


/***************************************************************************
 * Procedure.. removeLeadingPeriod
 * Author..... Mat
 * Date....... 2/29/96
 *
 * Checks the string for a leading period and replaces it with &per. if it
 * is there (assuming this is IPF output!). Returns true if a change was made.
 ***************************************************************************/
static Boolean removeLeadingPeriod( IString & string )
{
  if ( string.length() && string[1] == '.' )
  {
    string.change( ".", "&per.", 1, 1 );
    return true;
  }

  return false;
}


/***************************************************************************
 * Procedure.. Generator::wrapIndex
 * Author..... Mat
 * Date....... 12/30/97
 *
 * Returns an index for wrapping the specified string.  Starts searching
 * backwards from the specified start position.  Looks for the first space
 * and then continues backwards to the earliest contiguous space.  This
 * is done to avoid trailing spaces on lines.
 *
 * Return 0 if no valid wrap index is found.
 *
 * If the found index is 1, then check to make sure that the end of the
 * current line does not end with a space.  If it does, then 1 is not
 * a valid wrap index (assuming the text will be concatenated to the line),
 * since it would leave trailing spaces on the line.
 ***************************************************************************/
unsigned Generator::wrapIndex( const IString & string, unsigned startPos )
{
  unsigned index = string.lastIndexOfAnyOf( _wrapChars, startPos );

  // in RTF mode, don't wrap if previous character is a "\"
  if ( _mode == rtf )
  {
    while ( ( index > 1 ) && ( string[index-1] == '\\' ) )
      index = string.lastIndexOfAnyOf( _wrapChars, index - 2 );
  }

  // search backwards to avoid trailing spaces
  if ( index && ( string[index] == ' ' ) )
    index = string.lastIndexOfAnyBut( ' ', index ) + 1;

  // if wrap index is 1, check line to avoid trailing spaces
  if ( ( index == 1 ) && _line.length() )
  {
    if ( _line[_line.length()] == ' ' )
      index = 0;
  }

  return index;
}


/***************************************************************************
 * Procedure.. Generator::outputLine()
 * Author..... Mat
 * Date....... 11/11/97
 *
 * Sends the current line, appending a \n and resetting the line buffer.
 * If force is not set, then the line will only be sent if there is text
 * to be flushed.
 ***************************************************************************/
void Generator::outputLine( Boolean force )
{
  MEKASSERT( _output );
  Boolean gotText = ( _line.length() > 0 );
  if ( gotText )
  {
    if ( _mode == rtf )
      _line.change( delimiter, ' ' );
    _line.change( '\0', "" );  // remove \0, streams don't like them
    *_output << _line;
    _line = IString();  // empty string
    _minContentIndex = _maxContentIndex = _lineWrapIndex = 0;
  }
  if ( gotText || force )
  {
    *_output << '\n';
    checkOutput();
  }
}


/***************************************************************************
 * Procedure.. Generator::closeOutput
 * Author..... Mat
 * Date....... 2/18/99
 *
 * Send the final line, flush the output, and clear the reference.
 ***************************************************************************/
void Generator::closeOutput()
{
  if ( _output )
  {
    outputLine( false );
    *_output << flush;
    checkOutput();
    _output = 0;
  }
}


// ---------- STANDARD MAPPINGS ------------
// if the following Gins are not support, they get mapped to a more common Gin

void Generator::handleRow( const RowGin & gin )
{
  handlePara( ParaGin() );
}

void Generator::handleColumn( const ColumnGin & gin )
{
  handleLine( LineGin() );
}

void Generator::handleItem( const ItemGin & gin )
{
  handleLine( LineGin() );
}

void Generator::handleArt( const ArtGin & gin )
{
  // for runin art, insert a space, otherwise paragraph
  if ( gin.spot() <= ArtGin::bottom )
    handleText( TextGin( ' ' ) );
  else
    handlePara( ParaGin() );
}

void Generator::handleDivider( const DividerGin & gin )
{
  handlePara( ParaGin() );
}

