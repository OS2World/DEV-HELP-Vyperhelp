/***************************************************************************
 * File...... IpfParser.cpp
 * Author.... Mat
 *
 * Implementation for IpfParser which holds information for a Windows
 * Help Project.
 *
 * Copyright (C) 1998 MekTek
 ***************************************************************************/

// Standard C++
#include <iostream.h>

// OpenClass
#include <iexcept.hpp>

// MekTek
#include "MekTek.hpp"

// Generator
#include "Generator.hpp"
#include "ParserIndicator.hpp"
#include "ParserException.hpp"
#include "CDefineYacc.hpp"

// IpfParser
#include "IpfYacc.hpp"
#include "IpfParser.hpp"


//
// TEMPLATE DEFINITIONS
//
// These are picked out of the tempinc directory generated by the compiler.
// Since we are creating a LIB, the tempinc files never get linked in.
// We only need to include template instances that are private to the class.
#include <istkseq.c>
#include <ilnseq.c>
#include <iavlkss.c>
#include <ihshkb.c>
#include <ikskss.c>

// IStack <IpfParser::Mode>
#pragma define(IGLnSq<IpfParser::Mode,IStdOps<IpfParser::Mode> >)
#pragma define(IGLnSqCrs<IpfParser::Mode,IStdOps<IpfParser::Mode> >)
#pragma define(IGLinkedSequenceNode<IpfParser::Mode,IStdOps<IpfParser::Mode> >)
#pragma define(IWStOnSq<IpfParser::Mode,IStdOps<IpfParser::Mode>,IGLnSq<IpfParser::Mode,IStdOps<IpfParser::Mode> > >)
#pragma define(IWStackOnSeqCursor<IpfParser::Mode,IStdOps<IpfParser::Mode>,IGLnSq<IpfParser::Mode,IStdOps<IpfParser::Mode> > >)

// IQueue <Footnote *>
#pragma define(IGLnSqCrs<Footnote*,IStdOps<Footnote*> >)
#pragma define(IGLinkedSequenceNode<Footnote*,IStdOps<Footnote*> >)
#pragma define(IGLnSq<Footnote*,IStdOps<Footnote*> >)
#pragma define(IWQueueOnSeqCursor<Footnote*,IStdOps<Footnote*>,IGLnSq<Footnote*,IStdOps<Footnote*> > >)
#pragma define(IWQuOnSq<Footnote*,IStdOps<Footnote*>,IGLnSq<Footnote*,IStdOps<Footnote*> > >)

// IKeySet <PanelLink>
#pragma define(IGAvlKeySortedSetNode<PanelLink,int,IKCOps<PanelLink,int> >)
#pragma define(IGAvlKeySortedSetCursor<PanelLink,int,IKCOps<PanelLink,int> >)
#pragma define(IGAvlKSS<PanelLink,int,IKCOps<PanelLink,int> >)
#pragma define(IWKeySetOnKSSetCursor<PanelLink,int,IKCOps<PanelLink,int>,IGAvlKSS<PanelLink,int,IKCOps<PanelLink,int> > >)
#pragma define(IWKSOnKSS<PanelLink,int,IKCOps<PanelLink,int>,IGAvlKSS<PanelLink,int,IKCOps<PanelLink,int> > >)

// IKeySet <StringPair>
#pragma define(IGAvlKeySortedSetNode<StringPair,IString,IKCOps<StringPair,IString> >)
#pragma define(IGAvlKeySortedSetCursor<StringPair,IString,IKCOps<StringPair,IString> >)
#pragma define(IGAvlKSS<StringPair,IString,IKCOps<StringPair,IString> >)
#pragma define(IWKeySetOnKSSetCursor<StringPair,IString,IKCOps<StringPair,IString>,IGAvlKSS<StringPair,IString,IKCOps<StringPair,IString> > >)
#pragma define(IWKSOnKSS<StringPair,IString,IKCOps<StringPair,IString>,IGAvlKSS<StringPair,IString,IKCOps<StringPair,IString> > >)

// IKeyBag <StringPair>
#pragma define(IGHashKeyBagNode<StringPair,IString,IKEHOps<StringPair,IString> >)
#pragma define(IGHashKeyBagCursor<StringPair,IString,IKEHOps<StringPair,IString> >)
#pragma define(IHashKeyBag<StringPair,IString>)
#pragma define(IGHsKB<StringPair,IString,IKEHOps<StringPair,IString> >)



/***************************************************************************
 * Procedure.. IpfParser::IpfParser
 * Author..... Mat
 *
 ***************************************************************************/
IpfParser::IpfParser( const IString & ipfFile ):
    _ipfFile( ipfFile ),
    _activeFile( ipfFile ),
    _bitmaps( 30 ),
    _imbedText( 0 ),
    _mode( front ),
    _stack( 10 ),
    _foreColor( 0 ),
    _backColor( 0 ),
    _font( 0 ),
    _size( 0 ),
    _leftMargin( 0 ),
    _rightMargin( 0 ),
    _isBold( false ),
    _isItalic( false ),
    _isUnderline( false ),
    _tocLevel( 3 ),
    _windowCounter( 0 ),
    _footnotes( 50 ),
    _footnote( 0 ),
    _lineFlag( 0 ),
    _column( -1 ),
    _maxColumn( 0 ),
    _hasSectionText( false )
{
  _homeDir = _ipfFile.dir();
}


/***************************************************************************
 * Procedure.. IpfParser::~IpfParser
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Destructor cleans up all allocations.
 ***************************************************************************/
IpfParser::~IpfParser()
{
  // cleanup
  _symbols.removeAll();
}


/***************************************************************************
 * Procedure.. IpfParser::pushMode
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Push the current mode on the stack and set a new mode.  If the new mode
 * is footnote, then begin saving the footnote contents to a new Footnote
 * object (with the given ID).
 ***************************************************************************/
void IpfParser::pushMode( IpfParser::Mode mode, const IString * id )
{
  _stack.push( _mode );
  _mode = mode;

  // handle footnote mode
  if ( mode == footnote )
  {
    MEKASSERT( id );
    MEKASSERT( _footnote == 0 );  // nested footnotes are not supported!

    // flush text
    flushText();

    // create a new footnote destination
    _footnote = new Footnote( *id, 1, _footnoteWindowId );

    // reset and save all non-nested settings
    _saveForeColor = _foreColor;
    _foreColor = 0;
    _saveBackColor = _backColor;
    _backColor = 0;
    _saveFont = _font;
    _font = 0;
    _saveSize = _size;
    _size = 0;
    _saveLeftMargin = _leftMargin;
    _leftMargin = 0;
    _saveRightMargin = _rightMargin;
    _rightMargin = 0;
    _saveIsBold = _isBold;
    _isBold = false;
    _saveIsItalic = _isItalic;
    _isItalic = false;
    _saveIsUnderline = _isUnderline;
    _isUnderline = false;
  }
}


/***************************************************************************
 * Procedure.. IpfParser::popMode
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Check to see that the current mode is as specified, then pop a mode
 * off the stack.  When exiting from a footnote mode, do some special
 * processing to enquee the footnote contents and restore the non-nested
 * styles.
 ***************************************************************************/
void IpfParser::popMode( IpfParser::Mode mode )
{
  MEKASSERT( _mode == mode );

  // handle exit from footnote
  if ( mode == footnote )
  {
    // flush text
    flushText();

    // add this footnote to the queue
    _footnotes.enqueue( _footnote );
    _footnote = 0;

    // restore all non-nested styles
    delete _foreColor;
    _foreColor = _saveForeColor;
    delete _backColor;
    _backColor = _saveBackColor;
    delete _font;
    _font = _saveFont;
    delete _size;
    _size = _saveSize;
    delete _leftMargin;
    _leftMargin = _saveLeftMargin;
    delete _rightMargin;
    _rightMargin = _saveRightMargin;
    _isBold = _saveIsBold;
    _isItalic = _saveIsItalic;
    _isUnderline = _saveIsUnderline;
  }

  // pop your stack
  _stack.pop( _mode );
}


/***************************************************************************
 * Procedure.. IpfParser::imbedFile
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Process an imbedded (nested) file.
 ***************************************************************************/
void IpfParser::imbedFile( const Filename & imbedFile, Filename::StandardPath path )
{
  Filename filename = imbedFile;

  // search home directory, then given path
  if ( ! filename.locateOnPath( _homeDir ) )
    filename.locateOnStandardPath( path );

  // check the file date
  _gen->setInputFilename( filename );

  // save filename
  Filename save = _activeFile;
  _activeFile = filename;

  // parse the file
  IpfYacc ipf( filename, false );
  ipf.parseTo( *this, _pass );

  // restore filename
  _activeFile = save;
}


/***************************************************************************
 * Procedure.. IpfParser::imbedText
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Process an imbedded (nested) string from a macro.
 ***************************************************************************/
void IpfParser::imbedText( const IString & text )
{
  // create a string consumer
  SSLexStringConsumer consumer( text );

  // flag imbedded text
  _imbedText++;

  // parse the file
  IpfYacc ipf( consumer );
  ipf.parseTo( *this, _pass );

  // restore imbedded text level
  _imbedText--;
}


/***************************************************************************
 * Procedure.. IpfParser::setTitle
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Sets the document title
 ***************************************************************************/
void IpfParser::setTitle( const IString & title )
{
  _gen->setTitle( title );
}


/***************************************************************************
 * Procedure.. IpfParser::addBitmap
 * Author..... Mat
 * Date....... 10/22/98
 *
 * Add a bitmap to the current list, or locate it if it is already in the
 * list.  Also define the artwork with the Generator if it is new.  Return
 * the assigned ID of the artwork, or 0 if it is not a supported type.
 ***************************************************************************/
Boolean IpfParser::addBitmap( const IString & bitmapFile, IString & id )
{
  // locate the file in home directory or on artwork path
  Filename filename = bitmapFile;
  if ( ! filename.locateOnPath( _homeDir ) )
    filename.locateOnStandardPath( Filename::artwork );

  // see if file is already in list
  FilenameList::Cursor cursor( _bitmaps );
  IBoolean found = _bitmaps.locate( filename, cursor );

  // add to collection if necessary
  IGBitmap * bitmap = 0;
  if ( ! found )
  {
    // check the file date
    _gen->setInputFilename( filename );

    // try to load the bitmap
    try
    {
      bitmap = new IGBitmap( filename );
    }
    catch ( IException & except )
    {
      // unable to load bitmap
      warning( IString("Unsupported artwork: ") + filename.name() );
      return false;
    }

    // add to collection
    IBoolean ok = _bitmaps.add( filename, cursor );
    MEKASSERT( ok );
  }

  // use base filename as ID
  id = filename.base();

  // add to generator if necessary
  if ( ! found && bitmap )
  {
    _gen->defineArt( ArtDef( id, *bitmap ) );
    delete bitmap;
  }

  return true;
}


/***************************************************************************
 * Procedure.. IpfParser::addWindow
 * Author..... Mat
 * Date....... 10/27/98
 *
 * Add a window definition to the Generator's collection
 ***************************************************************************/
void IpfParser::addWindow( const WindowDef & window )
{
  _gen->defineWindow( window );
}



/***************************************************************************
 * Procedure.. IpfParser::addPanelLink
 * Author..... Mat
 * Date....... 10/29/98
 *
 * Add panel link information during pass 1.
 ***************************************************************************/
void IpfParser::addPanelLink( const PanelLink & link )
{
  _panels.add( link );
}


/***************************************************************************
 * Procedure.. IpfParser::addEntry
 * Author..... Mat
 * Date....... 10/29/98
 *
 * Add an index entry during pass 1.
 ***************************************************************************/
void IpfParser::addEntry( const StringPair & entry )
{
  _entries.add( entry );
}


/***************************************************************************
 * Procedure.. IpfParser::addSynonyms
 * Author..... Mat
 * Date....... 10/29/98
 *
 * For the given root, add all the synonyms in the space-separated list.
 ***************************************************************************/
void IpfParser::addSynonyms( const IString & root, const IString & synonyms )
{
  int i;
  int n = synonyms.numWords();
  for ( i = 1; i <= n; i++ )
    _synonyms.add( StringPair( root, synonyms.word( i ) ) );
}


/***************************************************************************
 * Procedure.. IpfParser::getPanelName
 * Author..... Mat
 * Date....... 10/29/98
 *
 * Given a panel resource id collected in pass 1, finc the corresponding
 * label name.
 ***************************************************************************/
IString IpfParser::getPanelName( int id )
{
  IKeySet<PanelLink,int>::Cursor cursor( _panels );
  Boolean found = _panels.locateElementWithKey( id, cursor );
  return found? cursor.element().name(): IString();
}


/***************************************************************************
 * Procedure.. IpfParser::getEntryText
 * Author..... Mat
 * Date....... 10/29/98
 *
 * Given an index "id" collected in pass 1, find the corresponding text.
 ***************************************************************************/
IString IpfParser::getEntryText( const IString & name )
{
  IKeySet<StringPair,IString>::Cursor cursor( _entries );
  Boolean found = _entries.locateElementWithKey( name, cursor );
  return found? cursor.element().other(): IString();
}


/***************************************************************************
 * Procedure.. IpfParser::sendSynonyms
 * Author..... Mat
 * Date....... 10/29/98
 *
 * Given a list of space-separated root words, find all synonyms related
 * to those root words and output them as hidden index entries.
 ***************************************************************************/
void IpfParser::sendSynonyms( const IString & roots )
{
  int i;
  int n = roots.numWords();
  Boolean found;
  IKeyBag<StringPair,IString>::Cursor cursor( _synonyms );

  for ( i = 1; i <= n; i++ )
  {
    // send index entries for this root word
    IString root = roots.word( i );
    found = _synonyms.locateElementWithKey( root, cursor );
    while ( found )
    {
      // "other" element holds synonym text
      KeywordGin * keyword = new KeywordGin( cursor.element().other(), false );
      sendGin( keyword );
      found = _synonyms.locateNextElementWithKey( root, cursor );
    }
  }
}


/***************************************************************************
 * Procedure.. IpfParser::sendGin
 * Author..... Mat
 * Date....... 10/13/98
 *
 * Send an arbitrary Gin, after flushing any cached text.
 ***************************************************************************/
void IpfParser::sendGin( Gin * gin )
{
  flushText();
  if ( _footnote )
    _footnote->list().add( GinPtr( gin, IINIT ) );
  else
  {
    *_gen << *gin;
    delete gin;
  }
}


/***************************************************************************
 * Procedure.. IpfParser::checkOutput
 * Author..... Mat
 * Date....... 11/12/98
 *
 * This function is called before sending any content (text or symbol):
 * - Set the "hasText" flags
 * - if isContent is true, then the line flag should be set (indicating that
 *   this content is directly the result of content in the source file.
 ***************************************************************************/
void IpfParser::checkOutput( Boolean isContent )
{
  if ( isContent )
    _lineFlag = true;  // indicate that this line has text content
  _hasSectionText = true;
}


/***************************************************************************
 * Procedure.. IpfParser::sendText
 * Author..... Mat
 * Date....... 10/13/98
 *
 * Add text to the outgoing cache.  isContent is set to true if the text
 * comes from IPF content (used or determining if an input line has content)
 ***************************************************************************/
void IpfParser::sendText( const IString & text, Boolean isContent )
{
  if ( text.length() )
  {
    checkOutput( isContent );
    _text += text;
  }
}


/***************************************************************************
 * Procedure.. IpfParser::flushText
 * Author..... Mat
 * Date....... 10/13/98
 *
 * Flush text from the cache.
 ***************************************************************************/
void IpfParser::flushText()
{
  if ( _text.length() )
  {
    if ( _footnote )
      _footnote->list().add( GinPtr( new TextGin( _text ), IINIT ) );
    else
      *_gen << _text;
    _text = IString();
  }
}


void IpfParser::sendSymbol( const Symbol & symbol )
{
  checkOutput( true );
  sendGin( new SymbolGin( symbol ) );
}


/***************************************************************************
 * Procedure.. IpfParser::addSymbol
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Add a symbol to the lookup table.  If the symbol has already been added,
 * return false.
 ***************************************************************************/
Boolean IpfParser::addSymbol( const SymbolLookup & lookup )
{
  return _symbols.add( lookup );
}


/***************************************************************************
 * Procedure.. IpfParser::locateSymbol
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Locate a symbol of the given name in the lookup table.  Return true
 * and set the SymbolLookup if found.  Otherwise, return false.
 ***************************************************************************/
Boolean IpfParser::locateSymbol( SymbolLookup & lookup )
{
  SymbolLookupSet::Cursor cursor( _symbols );
  Boolean found = _symbols.locateElementWithKey( lookup.name(), cursor );
  if ( found )
    lookup = cursor.element();
  return found;
}


/***************************************************************************
 * Procedure.. IpfParser::finishSection
 * Author..... Mat
 *
 * Reset all non-nested styles (color, font, etc) for a new section.
 * Also send a progress indicator (.) to the console.
 * Also sends all queued footnotes!
 ***************************************************************************/
void IpfParser::finishSection()
{
  // reset all non-nested settings
  delete _foreColor;
  _foreColor = 0;
  delete _backColor;
  _backColor = 0;
  delete _font;
  _font = 0;
  delete _size;
  _size = 0;
  delete _leftMargin;
  _leftMargin = 0;
  delete _rightMargin;
  _rightMargin = 0;
  _isBold = _isItalic = _isUnderline = false;

  // reset text flag
  _hasSectionText = false;

  // reset mode and empty the stack
  _mode = normal;
  _stack.removeAll();

}


/***************************************************************************
 * Procedure.. IpfParser::handlePop
 * Author..... Mat
 *
 * Send a Pop, and then reset all non-nested styles.
 ***************************************************************************/
void IpfParser::handlePop()
{
  // send pop
  sendGin( new PopGin() );

  // resend non-nested settings
  if ( _leftMargin )
    sendGin( new LeftMarginGin( *_leftMargin ) );
  if ( _rightMargin )
    sendGin( new RightMarginGin( *_rightMargin ) );
  if ( _foreColor )
    sendGin( new ColorGin( *_foreColor ) );
  if ( _backColor )
    sendGin( new BackColorGin( *_backColor ) );
  if ( _size )
    sendGin( new SizeGin( *_size ) );
  if ( _font )
    sendGin( new FontGin( *_font ) );
  // note: bold, italic and underline are always contained by hp tags, so
  //       we don't need to worry about cross-nesting
}


Boolean IpfParser::tableStart( unsigned maxColumn )
{
  MEKASSERT( maxColumn );
  Boolean ok = ( _maxColumn == 0 );
  _column = _maxColumn = maxColumn;
  return ok;
}


Boolean IpfParser::tableRow()
{
  Boolean expected = ( _maxColumn > 0 );
  _column = 0;
  return expected;
}


Boolean IpfParser::tableColumn( Boolean & isFirstColumn )
{
  Boolean expected = ( _column < _maxColumn );
  isFirstColumn = ( _column == 0 );
  _column++;
  return expected;
}


Boolean IpfParser::tableStop()
{
  Boolean expected = ( _maxColumn > 0 );
  _maxColumn = 0;
  return expected;
}


/***************************************************************************
 * Procedure.. IpfParser::sendPara
 * Author..... Mat
 * Date....... 11/12/98
 *
 * Set a flag
 ***************************************************************************/
void IpfParser::sendPara()
{
  // ignore first paragraph tag in the section
  if ( _hasSectionText )
    sendGin( new ParaGin() );
  else
    _hasSectionText = true;
}


void IpfParser::sendLine()
{
  if ( _hasSectionText )
    sendGin( new LineGin() );
  else
    _hasSectionText = true;
}


void IpfParser::setBold( Boolean isOn )
{
  if ( _isBold != isOn )
    sendGin( new BoldGin( _isBold = isOn ) );
}


void IpfParser::setItalic( Boolean isOn )
{
  if ( _isItalic != isOn )
    sendGin( new ItalicGin( _isItalic = isOn ) );
}


void IpfParser::setUnderline( Boolean isOn )
{
  if ( _isUnderline != isOn )
    sendGin( new UnderlineGin( _isUnderline = isOn ) );
}


/***************************************************************************
 * Procedure.. IpfParser::setForegroundColor
 * Author..... Mat
 * Date....... 10/15/98
 *
 * Set foreground color and save current setting.
 ***************************************************************************/
void IpfParser::setForegroundColor( const IColor & color )
{
  if ( _foreColor )
    delete _foreColor;
  _foreColor = new ColorGin( color );
  sendGin( new ColorGin( *_foreColor ) );
}


/***************************************************************************
 * Procedure.. IpfParser::setBackgroundColor
 * Author..... Mat
 * Date....... 10/15/98
 *
 * Set background color and save current setting.
 ***************************************************************************/
void IpfParser::setBackgroundColor( const IColor & color )
{
  if ( _backColor )
    delete _backColor;
  _backColor = new BackColorGin( color );
  sendGin( new BackColorGin( *_backColor ) );
}


/***************************************************************************
 * Procedure.. IpfParser::setFont
 * Author..... Mat
 * Date....... 10/15/98
 *
 * Set font and save current setting for reset after Pop.
 ***************************************************************************/
void IpfParser::setFont( const FontGin & font, const SizeGin & size )
{
  if ( _font )
    delete _font;
  if ( _size )
    delete _size;

  _font = new FontGin( font );
  _size = new SizeGin( size );
  sendGin( new FontGin( *_font ) );
  sendGin( new SizeGin( *_size ) );

  // IPF always resets attributes after changing fonts!
  setBold( false );
  setItalic( false );
  setUnderline( false );
}


/***************************************************************************
 * Procedure.. IpfParser::resetFont
 * Author..... Mat
 * Date....... 10/15/98
 *
 * Reset font to the given family.  pointSize is set to 0 to use default.
 ***************************************************************************/
void IpfParser::resetFont( FontInfo::Family family, unsigned pointSize )
{
  setFont( FontGin( family, IString() ),
           SizeGin( Distance( pointSize * 20, Distance::twips ) ) );
}


/***************************************************************************
 * Procedure.. IpfParser::setLeftMargin
 * Author..... Mat
 * Date....... 10/16/98
 *
 * Sets the left margin and saves the setting.
 ***************************************************************************/
void IpfParser::setLeftMargin( unsigned sizeInChars )
{
  if ( _leftMargin )
    delete _leftMargin;
  _leftMargin = new LeftMarginGin( false, Distance( sizeInChars, Distance::chars ) );
  sendGin( new LeftMarginGin( *_leftMargin ) );
}


/***************************************************************************
 * Procedure.. IpfParser::setRightMargin
 * Author..... Mat
 * Date....... 10/16/98
 *
 * Sets the left margin and saves the setting.
 ***************************************************************************/
void IpfParser::setRightMargin( unsigned sizeInChars )
{
  if ( _rightMargin )
    delete _rightMargin;
  _rightMargin = new RightMarginGin( false, Distance( sizeInChars, Distance::chars ) );
  sendGin( new RightMarginGin( *_rightMargin ) );
}


/***************************************************************************
 * Procedure.. IpfParser::warning
 * Author..... Mat
 * Date....... 10/13/98
 *
 * Log a warning condition.  If line = 0, then line/col is unknown.
 * If line = SSUnsigned32Max, then error is at EOF
 ***************************************************************************/
void IpfParser::warning( const IString & text, unsigned line, unsigned col )
{
  // make sure an indicator is attached
  if ( ! indicator() )
    return;

  // construct output string
  IString warningText = text;

  // append line/col info
  if ( _imbedText == 0 && line )
  {
    warningText += IString(" [") + _activeFile.name() + IString(':');
    if ( line == SSUnsigned32Max )
      warningText += IString("EOF");
    else
      warningText += IString(line) + IString('/') + IString(col);
    warningText += IString(']');
  }

  indicator()->warning( warningText );
}


Boolean IpfParser::hasContext(int id) const
{
  return _contexts.containsElementWithKey(id);
}


IString IpfParser::getContext(int id) const
{
  IKeySet<PanelLink,int>::Cursor cursor( _contexts );
  Boolean found = _contexts.locateElementWithKey( id, cursor );
  IASSERTSTATE( found );
  // set current id
  return cursor.element().name();
}


void IpfParser::setId( const IString & contextName, int id )
{
  _contexts.add( PanelLink(contextName, id) );
}


/***************************************************************************
 * Procedure.. IpfParser::finish
 * Author..... Mat
 * Date....... 10/20/98
 *
 * Flush all remaining text and finish the generation.
 ***************************************************************************/
void IpfParser::finish()
{
  flushText();
  _gen->finish();
}


/***************************************************************************
 * Procedure.. IpfParser::generate
 * Author..... Mat
 *
 ***************************************************************************/
void IpfParser::generate( Generator & gen )
{
  // save pointer to Generator
  _gen = &gen;

  try
  {
    // create a window ID for footnotes
    _footnoteWindowId = nextWindowId();
    gen.defineWindow(
       WindowDef( _footnoteWindowId,
                  "Footnote",
                  Position( Position::center ),
                  Position( Distance( 10, Distance::percent ) ),
                  Distance( 50, Distance::percent ),
                  Distance( 50, Distance::percent ),
                  WindowDef::sizeBorder,
                  WindowDef::allScroll,
                  true, true, true, true ) );

    // look for a header file with same root name
    Filename headerFile = _ipfFile.fullBase() + ".H";
    if ( headerFile.isAccessible( Filename::readAccess ) )
    {
      ITRACE_DEVELOP(IString("Found header file: ") + headerFile);
      CDefineYacc cdef( headerFile, headerFile.dir() );
      cdef.parseTo( *this );
    }

    // parse the IPF file (2 passes)
    for ( _pass = 1; _pass <= 2; _pass++ )
    {
      IpfYacc ipf( _ipfFile );

      // setup indicator
      if ( indicator() )
      {
        indicator()->setTask( IString("PASS ") + IString(_pass) );
        indicator()->setStatus( _ipfFile.name() );
        indicator()->setCurrent( 0 );
        indicator()->setTotal( ipf.size() );
      }

      // parse the file
      ipf.parseTo( *this, _pass );
    }
    MEKASSERT( _mode == front );

    // send all footnote contents
    MEKASSERT( _footnote == 0 );
    while ( ! _footnotes.isEmpty() )
    {
      _footnotes.dequeue( _footnote );
      _footnote->sendTo( gen );
      delete _footnote;
    }
    _footnote = 0;
  }
  catch ( const SSException & ss )
  {
    finish();
    ITHROW( ParserException( ss ) );
  }

  // finish generator output
  finish();
}

